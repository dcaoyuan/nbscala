// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.3,
// (C) 2004-2008 Robert Grimm,
// on Thursday, November 13, 2008 at 9:24:56 PM.
// Edit at your own risk.
// ===========================================================================

package xtc.typical;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>xtc.typical.Typical</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.3, (C) 2004-2008 Robert Grimm.
 */
public final class TypicalParser extends ParserBase {

  /** The TYPICAL_KEYWORDS set. */
  public static final Set<String> TYPICAL_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fNameSpaceStructure;
    Result fEqualStructure;
    Result fEqualStructure$$Star1;
    Result fParameters;
    Result fParameters$$Star1;
    Result fPatternMatching;
    Result fPatternMatching$$Star1;
    Result fPatternMatch;
    Result fPatterns;
    Result fPatterns$$Star1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fPattern;
    Result fWhenPattern;
    Result fConsPattern;
    Result fAtomicPattern;
    Result fVariable;
    Result fFieldPattern;
    Result fExpression;
    Result fLogicalOrExpression;
    Result fConsExpression;
    Result fFunctionApplication;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fArguments;
    Result fArguments$$Plus1;
    Result fFieldExpression;
    Result fPrimaryExpression;
    Result fLetBinding;
    Result fRequireArgs;
    Result fMessageTag;
    Result fErrorClause;
    Result fFieldAssignment;
    Result fLiteral;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fLowerID;
    Result fUpperID;
    Result fAliasedType;
    Result fFunctionType;
    Result fTupleType;
    Result fTupleType$$Plus1;
    Result fConstructedType;
    Result fTypeConstructor;
    Result fFieldType;
    Result fPolyTypeConstructor;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fExponent;
    Result fExponent$$Plus1;
    Result fLowerIdentifier;
    Result fUpperIdentifier;
    Result fIdentifier;
    Result fWord;
    Result fWord$$Star1;
    Result fKeyword;
    Result fSymbol;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class TypicalParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public TypicalParser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public TypicalParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new TypicalParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Module.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pModuleDeclaration(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pDefinition(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyResult = pEndOfFile(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.createFromPair("Module", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Definition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("scope")) {

      yyResult = pPatternMatching(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("ScopeDefinition", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pNameSpaceDefinition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("attribute")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pAliasedType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("AttributeDefinition", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("eqattribute")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pAliasedType(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("EqualAttributeDefinition", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("equality")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("=")) {

          yyResult = pEqualStructure(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = Pair.empty();
            while (true) {

              yyBase   = yyRepetition1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("|")) {

                yyResult = pEqualStructure(yyResult.index);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  final Node v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                  continue;
                }
              } else {
                yyError = yyError.select("'|' expected", yyBase);
              }
              break;
            }
            { // Start scope for v$g$3.
              final Pair<Node> v$g$3 = yyRepValue1.reverse();

              yyValue = GNode.create("EqualityDefinition", v$g$3.size() + 2).
                add(v$g$1).add(v$g$2).addAll(v$g$3);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for v$g$3.
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("mltype")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeParameters(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyResult = pLowerIdentifier(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pTypeInformation(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("TypeDefinition", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }
      } // End scope for v$g$1.
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("mlvalue")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyResult = pParameters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ValueDefinition", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("definition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.NameSpaceDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameSpaceDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("namespace")) {

      yyResult = pNameSpaceStructure(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pKeyword(yyBase);
          if (yyResult.hasValue("and")) {

            yyResult = pNameSpaceStructure(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("'and' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("NameSpaceDefinition", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("name space definition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ModuleDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModuleDeclaration(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("module")) {

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(".")) {

            yyResult = pIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("'.' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<String> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.createFromPair("ModuleDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("module declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.NameSpaceStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameSpaceStructure(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fNameSpaceStructure) 
      yyColumn.chunk1.fNameSpaceStructure = pNameSpaceStructure$1(yyStart);
    return yyColumn.chunk1.fNameSpaceStructure;
  }

  /** Actually parse xtc.typical.Typical.NameSpaceStructure. */
  private Result pNameSpaceStructure$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNameSpaceStructure$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pLowerIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pPatternMatching(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("NameSpaceStructure", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.NameSpaceStructure$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNameSpaceStructure$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("default")) {
      yyValue = "default";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("name space structure expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.EqualStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualStructure(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fEqualStructure) 
      yyColumn.chunk1.fEqualStructure = pEqualStructure$1(yyStart);
    return yyColumn.chunk1.fEqualStructure;
  }

  /** Actually parse xtc.typical.Typical.EqualStructure. */
  private Result pEqualStructure$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pEqualStructure$$Choice1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyResult = pEqualStructure$$Star1(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Node> v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyValue = GNode.create("EqualStructure", v$g$3.size() + 2).
                add(v$g$1).add(v$g$2).addAll(v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.EqualStructure$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualStructure$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_")) {

      yyValue = GNode.create("WildCard", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equal structure expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.EqualStructure$$Choice2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualStructure$$Choice2(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pWildCard(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pVariable(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("equal structure expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.EqualStructure$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualStructure$$Star1(final int yyStart) 
    throws IOException {

    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fEqualStructure$$Star1) 
      yyColumn.chunk1.fEqualStructure$$Star1 = pEqualStructure$$Star1$1(yyStart);
    return yyColumn.chunk1.fEqualStructure$$Star1;
  }

  /** Actually parse xtc.typical.Typical.EqualStructure$$Star1. */
  private Result pEqualStructure$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pEqualStructure$$Choice2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyResult = pEqualStructure$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$6 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Parameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameters(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParameters) 
      yyColumn.chunk1.fParameters = pParameters$1(yyStart);
    return yyColumn.chunk1.fParameters;
  }

  /** Actually parse xtc.typical.Typical.Parameters. */
  private Result pParameters$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameters$$Star1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Parameters", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.Parameters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameters$$Star1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParameters$$Star1) 
      yyColumn.chunk1.fParameters$$Star1 = pParameters$$Star1$1(yyStart);
    return yyColumn.chunk1.fParameters$$Star1;
  }

  /** Actually parse xtc.typical.Typical.Parameters$$Star1. */
  private Result pParameters$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameter(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyResult = pParameters$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Parameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameter(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pAliasedType(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Parameter", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Alternative 2.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pAliasedType(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
      { // Start scope for v$g$4.
        final Node v$g$4 = yyOpValue1;

        yyValue = GNode.create("Parameter", v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$4.
    }

    // Done.
    yyError = yyError.select("parameter expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PatternMatching.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternMatching(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternMatching) 
      yyColumn.chunk1.fPatternMatching = pPatternMatching$1(yyStart);
    return yyColumn.chunk1.fPatternMatching;
  }

  /** Actually parse xtc.typical.Typical.PatternMatching. */
  private Result pPatternMatching$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase   = yyOption1;
    yyResult = pSymbol(yyBase);
    if (yyResult.hasValue("|")) {

      yyOption1  = yyResult.index;
    } else {
      yyError = yyError.select("'|' expected", yyBase);
    }

    yyResult = pPatternMatch(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pPatternMatching$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("PatternMatching", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.PatternMatching$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternMatching$$Star1(final int yyStart) 
    throws IOException {

    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternMatching$$Star1) 
      yyColumn.chunk1.fPatternMatching$$Star1 = pPatternMatching$$Star1$1(yyStart);
    return yyColumn.chunk1.fPatternMatching$$Star1;
  }

  /** Actually parse xtc.typical.Typical.PatternMatching$$Star1. */
  private Result pPatternMatching$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pPatternMatch(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pPatternMatching$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PatternMatch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternMatch(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatternMatch) 
      yyColumn.chunk1.fPatternMatch = pPatternMatch$1(yyStart);
    return yyColumn.chunk1.fPatternMatch;
  }

  /** Actually parse xtc.typical.Typical.PatternMatch. */
  private Result pPatternMatch$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPatterns(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("->")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("PatternMatch", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("'->' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Patterns.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatterns(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatterns) 
      yyColumn.chunk1.fPatterns = pPatterns$1(yyStart);
    return yyColumn.chunk1.fPatterns;
  }

  /** Actually parse xtc.typical.Typical.Patterns. */
  private Result pPatterns$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pPatterns$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Patterns", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.Patterns$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatterns$$Star1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPatterns$$Star1) 
      yyColumn.chunk1.fPatterns$$Star1 = pPatterns$$Star1$1(yyStart);
    return yyColumn.chunk1.fPatterns$$Star1;
  }

  /** Actually parse xtc.typical.Typical.Patterns$$Star1. */
  private Result pPatterns$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pPatterns$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Pattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPattern(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPattern) 
      yyColumn.chunk2.fPattern = pPattern$1(yyStart);
    return yyColumn.chunk2.fPattern;
  }

  /** Actually parse xtc.typical.Typical.Pattern. */
  private Result pPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTuplePattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.TuplePattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTuplePattern(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pWhenPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pWhenPattern(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("TuplePattern", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pWhenPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.WhenPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhenPattern(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fWhenPattern) 
      yyColumn.chunk2.fWhenPattern = pWhenPattern$1(yyStart);
    return yyColumn.chunk2.fWhenPattern;
  }

  /** Actually parse xtc.typical.Typical.WhenPattern. */
  private Result pWhenPattern$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pAsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pWhenPattern$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.WhenPattern$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhenPattern$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("when")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("WhenPattern", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("when pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.AsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAsPattern(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pTypedPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAsPattern$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.AsPattern$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAsPattern$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("as")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AsPattern", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("as pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.TypedPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypedPattern(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pConsPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pTypedPattern$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.TypedPattern$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypedPattern$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursive>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(":")) {

      yyResult = pAliasedType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("TypedPattern", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("typed pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ConsPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConsPattern(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConsPattern) 
      yyColumn.chunk2.fConsPattern = pConsPattern$1(yyStart);
    return yyColumn.chunk2.fConsPattern;
  }

  /** Actually parse xtc.typical.Typical.ConsPattern. */
  private Result pConsPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pAtomicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("::")) {

        yyResult = pConsPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("ConsPattern", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'::' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pAtomicPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.AtomicPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAtomicPattern(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAtomicPattern) 
      yyColumn.chunk2.fAtomicPattern = pAtomicPattern$1(yyStart);
    return yyColumn.chunk2.fAtomicPattern;
  }

  /** Actually parse xtc.typical.Typical.AtomicPattern. */
  private Result pAtomicPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <RecordPattern>.

    yyResult = pRecordPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <List>.

    yyResult = pListPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TypeConstructor>.

    yyResult = pTypeConstructorPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Parenthesised>.

    yyResult = pParenthesisedPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Variable>.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <BottomPattern>.

    yyResult = pBottomPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_")) {

      yyValue = GNode.create("WildCard", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Literal>.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("atomic pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Variable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fVariable) 
      yyColumn.chunk2.fVariable = pVariable$1(yyStart);
    return yyColumn.chunk2.fVariable;
  }

  /** Actually parse xtc.typical.Typical.Variable. */
  private Result pVariable$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Variable", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ParenthesisedPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParenthesisedPattern(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("parenthesised pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.TypeConstructorPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeConstructorPattern(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPatternParameters(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("TypeConstructorPattern", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pWildCard(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("TypeConstructorPattern", v$g$1, v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyOption1  = yyChoice1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyOption1  = yyResult.index;
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      yyValue = GNode.create("TypeConstructorPattern", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PatternParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPatternParameters(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pWhenPattern(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pWhenPattern(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("PatternParameters", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("pattern parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.BottomPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBottomPattern(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("bottom")) {

      yyValue = GNode.create("BottomPattern", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("bottom pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ListPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pListPattern(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pWhenPattern(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pWhenPattern(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = GNode.createFromPair("ListPattern", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("]")) {

        yyValue = GNode.create("ListPattern", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("']' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("list pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RecordPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRecordPattern(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pFieldPattern(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pFieldPattern(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("}")) {

            yyValue = GNode.createFromPair("RecordPattern", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("}")) {

        yyValue = GNode.create("RecordPattern", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'}' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("record pattern expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FieldPattern.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldPattern(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFieldPattern) 
      yyColumn.chunk2.fFieldPattern = pFieldPattern$1(yyStart);
    return yyColumn.chunk2.fFieldPattern;
  }

  /** Actually parse xtc.typical.Typical.FieldPattern. */
  private Result pFieldPattern$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pWhenPattern(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("FieldPattern", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.WildCard.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWildCard(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_")) {

      yyValue = GNode.create("WildCard", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("wild card expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpression) 
      yyColumn.chunk2.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk2.fExpression;
  }

  /** Actually parse xtc.typical.Typical.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTupleLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.TupleLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pLogicalOrExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }

      if (yyRepeated1) {
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("TupleLiteral", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLogicalOrExpression) 
      yyColumn.chunk2.fLogicalOrExpression = pLogicalOrExpression$1(yyStart);
    return yyColumn.chunk2.fLogicalOrExpression;
  }

  /** Actually parse xtc.typical.Typical.LogicalOrExpression. */
  private Result pLogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pLogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pLogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pEqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pEqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pRelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pEqualityOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pRelationalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.EqualityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NotEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!=")) {
      yyValue = "!=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equality operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$4 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        final Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, v$g$4, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pRelationalOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pAdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerRelationalOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatRelationalOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.IntegerRelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerRelationalOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <IntegerLessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IntegerLess>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IntegerGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IntegerGreater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer relational operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FloatRelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatRelationalOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatLessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=.")) {
      yyValue = "<=.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FloatLess>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<.")) {
      yyValue = "<.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FloatGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=.")) {
      yyValue = ">=.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FloatGreater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">.")) {
      yyValue = ">.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("float relational operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pConcatenationExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$4 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        final Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, v$g$4, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pMultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ConcatenationExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConcatenationExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pMultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$4 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pConcatenationExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        final Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, v$g$4, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.ConcatenationExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConcatenationExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pConcatenationOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pMultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ConcatenationExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.AdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ConcatenationOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConcatenationOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {
      yyValue = "^";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("@")) {
      yyValue = "@";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("concatenation operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.IntegerAdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerAdditiveOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <IntegerPlus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {
      yyValue = "+";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IntegerMinus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {
      yyValue = "-";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer additive operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FloatAdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatAdditiveOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatPlus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+.")) {
      yyValue = "+.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FloatMinus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-.")) {
      yyValue = "-.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("float additive operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pConsExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.typical.Typical.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pConsExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.MultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.IntegerMultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <IntegerTimes>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {
      yyValue = "*";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IntegerOver>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/")) {
      yyValue = "/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Modulo>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("%")) {
      yyValue = "%";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer multiplicative operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FloatMultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatTimes>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*.")) {
      yyValue = "*.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <FloatOver>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/.")) {
      yyValue = "/.";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("float multiplicative operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ConsExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConsExpression(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConsExpression) 
      yyColumn.chunk2.fConsExpression = pConsExpression$1(yyStart);
    return yyColumn.chunk2.fConsExpression;
  }

  /** Actually parse xtc.typical.Typical.ConsExpression. */
  private Result pConsExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Recursive>.

    yyResult = pFunctionApplication(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("::")) {

        yyResult = pConsExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("ConsExpression", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'::' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pFunctionApplication(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FunctionApplication.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionApplication(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fFunctionApplication) 
      yyColumn.chunk2.fFunctionApplication = pFunctionApplication$1(yyStart);
    return yyColumn.chunk2.fFunctionApplication;
  }

  /** Actually parse xtc.typical.Typical.FunctionApplication. */
  private Result pFunctionApplication$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Library>.

    yyResult = pUpperID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyResult = pLowerID(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyResult = pArguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyValue = GNode.create("FunctionApplication", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative <Normal>.

    yyResult = pLowerID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$4 = yyResult.semanticValue();

      yyResult = pArguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$5 = yyResult.semanticValue();

        yyValue = GNode.create("FunctionApplication", v$g$4, v$g$5);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pFieldExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fArguments) 
      yyColumn.chunk3.fArguments = pArguments$1(yyStart);
    return yyColumn.chunk3.fArguments;
  }

  /** Actually parse xtc.typical.Typical.Arguments. */
  private Result pArguments$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArguments$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Arguments", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.Arguments$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments$$Plus1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fArguments$$Plus1) 
      yyColumn.chunk3.fArguments$$Plus1 = pArguments$$Plus1$1(yyStart);
    return yyColumn.chunk3.fArguments$$Plus1;
  }

  /** Actually parse xtc.typical.Typical.Arguments$$Plus1. */
  private Result pArguments$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArgument(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pArguments$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Argument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArgument(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFieldExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PredicateArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicateArgument(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyBase   = yyResult.index;
      yyResult = pKeyword(yyBase);
      if (yyResult.hasValue("predicate")) {

        yyResult = pPatterns(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("PredicateArgument", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'predicate' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("predicate")) {

      yyResult = pPatterns(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PredicateArgument", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("predicate argument expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PredicateExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicateExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPredicateArgument(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PredicateExpression", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FieldExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldExpression(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFieldExpression) 
      yyColumn.chunk3.fFieldExpression = pFieldExpression$1(yyStart);
    return yyColumn.chunk3.fFieldExpression;
  }

  /** Actually parse xtc.typical.Typical.FieldExpression. */
  private Result pFieldExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pFieldExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.FieldExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("FieldExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("field expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpression(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPrimaryExpression) 
      yyColumn.chunk3.fPrimaryExpression = pPrimaryExpression$1(yyStart);
    return yyColumn.chunk3.fPrimaryExpression;
  }

  /** Actually parse xtc.typical.Typical.PrimaryExpression. */
  private Result pPrimaryExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("begin")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("end")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'end' expected", yyBase);
        }
      }
    }

    // Alternative <Parenthesised>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <PredicateExpression>.

    yyResult = pPredicateExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ReduceExpression>.

    yyResult = pReduceExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Function>.

    yyResult = pFunctionExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fun>.

    yyResult = pFunExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Record>.

    yyResult = pRecordExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pPrimaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Match>.

    yyResult = pMatchExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TupleConstructor>.

    yyResult = pTupleConstructor(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ListLiteral>.

    yyResult = pListLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Let>.

    yyResult = pLetExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Error>.

    yyResult = pErrorClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Assertion>.

    yyResult = pAssertClause(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Guard>.

    yyResult = pGuardExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Require>.

    yyResult = pRequireExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <IfElse>.

    yyResult = pIfElseExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <If>.

    yyResult = pIfExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LowerIdentifier>.

    yyResult = pLowerID(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Literal>.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LetExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLetExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("let")) {

      yyResult = pLetBindings(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("in")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("LetExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'in' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("let expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LetBindings.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLetBindings(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLetBinding(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("and")) {

          yyResult = pLetBinding(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'and' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("LetBindings", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LetBinding.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLetBinding(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLetBinding) 
      yyColumn.chunk3.fLetBinding = pLetBinding$1(yyStart);
    return yyColumn.chunk3.fLetBinding;
  }

  /** Actually parse xtc.typical.Typical.LetBinding. */
  private Result pLetBinding$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPattern(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("LetBinding", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FunctionExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("function")) {

      yyResult = pPatternMatching(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("FunctionExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("function expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FunExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("fun")) {

      yyResult = pParameters(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("->")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("FunExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'->' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("fun expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.MatchExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMatchExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("match")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("with")) {

          yyResult = pPatternMatching(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("MatchExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'with' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("match expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RequireExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequireExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("require")) {

      yyResult = pRequireArgs(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pKeyword(yyBase);
          if (yyResult.hasValue("and")) {

            yyResult = pRequireArgs(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("'and' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pKeyword(yyBase);
          if (yyResult.hasValue("in")) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("RequireExpression", v$g$2.size() + 2).
                add(v$g$1).addAll(v$g$2).add(v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'in' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("require expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RequireArgs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRequireArgs(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fRequireArgs) 
      yyColumn.chunk3.fRequireArgs = pRequireArgs$1(yyStart);
    return yyColumn.chunk3.fRequireArgs;
  }

  /** Actually parse xtc.typical.Typical.RequireArgs. */
  private Result pRequireArgs$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pMessageTag(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyBase   = yyOption1;
          yyResult = pKeyword(yyBase);
          if (yyResult.hasValue("at")) {

            yyResult = pLowerID(yyResult.index);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
          } else {
            yyError = yyError.select("'at' expected", yyBase);
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyValue = GNode.create("RequireArgs", v$g$1, v$g$2, v$g$3, v$g$4);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$4.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.MessageTag.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMessageTag(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fMessageTag) 
      yyColumn.chunk3.fMessageTag = pMessageTag$1(yyStart);
    return yyColumn.chunk3.fMessageTag;
  }

  /** Actually parse xtc.typical.Typical.MessageTag. */
  private Result pMessageTag$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("warning")) {
      final String v$g$1 = "warning";

      yyValue = GNode.create("MessageTag", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("error")) {
      final String v$g$2 = "error";

      yyValue = GNode.create("MessageTag", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("message tag expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.GuardExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGuardExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("guard")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pErrorClause(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("GuardExpression", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("guard expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ErrorClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pErrorClause(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fErrorClause) 
      yyColumn.chunk3.fErrorClause = pErrorClause$1(yyStart);
    return yyColumn.chunk3.fErrorClause;
  }

  /** Actually parse xtc.typical.Typical.ErrorClause. */
  private Result pErrorClause$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pMessageTag(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("at")) {

          yyResult = pLowerID(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("'at' expected", yyBase);
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("ErrorClause", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.AssertClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssertClause(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("assert")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("AssertClause", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("assert clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.TupleConstructor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleConstructor(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pLogicalOrExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(",")) {

              yyResult = pLogicalOrExpression(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                final Node v$el$1 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                continue;
              }
            } else {
              yyError = yyError.select("',' expected", yyBase);
            }
            break;
          }
          { // Start scope for v$g$3.
            final Pair<Node> v$g$3 = yyRepValue1.reverse();

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyValue = GNode.create("TupleConstructor", v$g$3.size() + 2).
                add(v$g$1).add(v$g$2).addAll(v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("TupleConstructor", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.RecordExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRecordExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pWithExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyResult = pFieldAssignment(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(",")) {

              yyResult = pFieldAssignment(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                final Node v$el$2 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
                continue;
              }
            } else {
              yyError = yyError.select("',' expected", yyBase);
            }
            break;
          }
          { // Start scope for v$g$3.
            final Pair<Node> v$g$3 = yyRepValue1.reverse();

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("}")) {

              yyValue = GNode.create("RecordExpression", v$g$3.size() + 2).
                add(v$g$1).add(v$g$2).addAll(v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'}' expected", yyBase);
            }
          } // End scope for v$g$3.
        }
      } // End scope for v$g$1.

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("}")) {

        yyValue = GNode.create("RecordExpression", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'}' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("record expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.WithExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWithExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pKeyword(yyBase);
      if (yyResult.hasValue("with")) {

        yyValue = GNode.create("WithExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'with' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.FieldAssignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldAssignment(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFieldAssignment) 
      yyColumn.chunk3.fFieldAssignment = pFieldAssignment$1(yyStart);
    return yyColumn.chunk3.fFieldAssignment;
  }

  /** Actually parse xtc.typical.Typical.FieldAssignment. */
  private Result pFieldAssignment$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pLogicalOrExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("FieldAssignment", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.IfExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("if")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("then")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("IfExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'then' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("if expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.IfElseExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfElseExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("if")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("then")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pKeyword(yyBase);
            if (yyResult.hasValue("else")) {

              yyResult = pExpression(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$3 = yyResult.semanticValue();

                yyValue = GNode.create("IfElseExpression", v$g$1, v$g$2, v$g$3);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'else' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'then' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("if else expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ListLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pListLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pLogicalOrExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pLogicalOrExpression(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = GNode.createFromPair("ListLiteral", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("]")) {

        yyValue = GNode.create("ListLiteral", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("']' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("list literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLiteral) 
      yyColumn.chunk3.fLiteral = pLiteral$1(yyStart);
    return yyColumn.chunk3.fLiteral;
  }

  /** Actually parse xtc.typical.Typical.Literal. */
  private Result pLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("bottom")) {

      yyValue = GNode.create("Bottom", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ReduceExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReduceExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Reduce>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("reduce")) {

      yyBase   = yyResult.index;
      yyResult = pKeyword(yyBase);
      if (yyResult.hasValue("to")) {

        yyResult = pReduceOptions(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyResult = pLiteral(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pKeyword(yyBase);
            if (yyResult.hasValue("with")) {

              yyResult = pPatternMatching(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$3 = yyResult.semanticValue();

                yyValue = GNode.create("ReduceExpression", v$g$1, v$g$2, v$g$3);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'with' expected", yyBase);
            }
          }
        }
      } else {
        yyError = yyError.select("'to' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("reduce expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.ReduceOptions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReduceOptions(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLowerIdentifier(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<String> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ReduceOptions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.LowerID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLowerID(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fLowerID) 
      yyColumn.chunk4.fLowerID = pLowerID$1(yyStart);
    return yyColumn.chunk4.fLowerID;
  }

  /** Actually parse xtc.typical.Typical.LowerID. */
  private Result pLowerID$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("LowerID", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Typical.UpperID.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUpperID(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fUpperID) 
      yyColumn.chunk4.fUpperID = pUpperID$1(yyStart);
    return yyColumn.chunk4.fUpperID;
  }

  /** Actually parse xtc.typical.Typical.UpperID. */
  private Result pUpperID$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("UpperID", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.AliasedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedType(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fAliasedType) 
      yyColumn.chunk4.fAliasedType = pAliasedType$1(yyStart);
    return yyColumn.chunk4.fAliasedType;
  }

  /** Actually parse xtc.typical.Type.AliasedType. */
  private Result pAliasedType$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pFunctionType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAliasedType$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.AliasedType$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAliasedType$$Tail1(final int yyStart) throws IOException {
    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("as")) {

      yyResult = pTypeVariable(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AliasedType", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("aliased type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.FunctionType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionType(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fFunctionType) 
      yyColumn.chunk4.fFunctionType = pFunctionType$1(yyStart);
    return yyColumn.chunk4.fFunctionType;
  }

  /** Actually parse xtc.typical.Type.FunctionType. */
  private Result pFunctionType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pTupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("->")) {

        yyResult = pFunctionType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("FunctionType", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'->' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pTupleType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.TupleType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleType(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTupleType) 
      yyColumn.chunk4.fTupleType = pTupleType$1(yyStart);
    return yyColumn.chunk4.fTupleType;
  }

  /** Actually parse xtc.typical.Type.TupleType. */
  private Result pTupleType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Tuple>.

    yyResult = pConstructedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pTupleType$$Plus1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("TupleType", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pConstructedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.TupleType$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTupleType$$Plus1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTupleType$$Plus1) 
      yyColumn.chunk4.fTupleType$$Plus1 = pTupleType$$Plus1$1(yyStart);
    return yyColumn.chunk4.fTupleType$$Plus1;
  }

  /** Actually parse xtc.typical.Typical.TupleType$$Plus1. */
  private Result pTupleType$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pConstructedType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pTupleType$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Node>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("tuple type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.ConstructedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstructedType(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fConstructedType) 
      yyColumn.chunk4.fConstructedType = pConstructedType$1(yyStart);
    return yyColumn.chunk4.fConstructedType;
  }

  /** Actually parse xtc.typical.Type.ConstructedType. */
  private Result pConstructedType$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Nary>.

    yyResult = pNaryConstructedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pConstructedType$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Alternative <Base>.

    yyResult = pPrimaryType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pConstructedType$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$5 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$5, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$6.
        final Pair<Action<Node>> v$6 = yyRepValue1.reverse();

        yyValue = apply(v$6, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$6.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.ConstructedType$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstructedType$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Unary>.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("ConstructedType", v$1, v$g$2);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.NaryConstructedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNaryConstructedType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNaryType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("NaryConstructedType", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.NaryType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNaryType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pConstructedType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pConstructedType(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("NaryType", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("nary type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.PrimaryType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("bool")) {

      yyValue = GNode.create("BooleanType", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("int")) {

      yyValue = GNode.create("IntType", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("float32")) {

      yyValue = GNode.create("Float32", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("float64")) {

      yyValue = GNode.create("Float64", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("string")) {

      yyValue = GNode.create("StringType", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("any")) {

      yyValue = GNode.create("AnyType", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("UserDefinedType", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("\'")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("TypeVariable", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("Node")) {

      yyResult = pTypeVariable(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("ConstraintType", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 10.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyOption1  = yyResult.index;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("|")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("'|' expected", yyBase);
      }

      yyResult = pPolyTypeConstructor(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("|")) {

            yyResult = pPolyTypeConstructor(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("'|' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = GNode.createFromPair("PolyVariantType", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Alternative <Parenthesized>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pAliasedType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.TypeVariable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeVariable(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("\'")) {

      yyResult = pLowerIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("TypeVariable", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("type variable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.TypeParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParameters(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Nary>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pTypeVariable(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pTypeVariable(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("TypeParameters", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Unary>.

    yyResult = pTypeVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("TypeParameters", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.TypeInformation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeInformation(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyBase   = yyOption1;
    yyResult = pSymbol(yyBase);
    if (yyResult.hasValue("|")) {

      yyOption1  = yyResult.index;
    } else {
      yyError = yyError.select("'|' expected", yyBase);
    }

    yyResult = pTypeConstructor(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("|")) {

          yyResult = pTypeConstructor(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("VariantDeclaration", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pFieldType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pFieldType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("}")) {

            yyValue = GNode.createFromPair("RecordDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyOption1  = yyResult.index;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("|")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("'|' expected", yyBase);
      }

      yyResult = pPolyTypeConstructor(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("|")) {

            yyResult = pPolyTypeConstructor(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("'|' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = GNode.createFromPair("PolyVariantDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("type information expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.TypeConstructor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeConstructor(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fTypeConstructor) 
      yyColumn.chunk4.fTypeConstructor = pTypeConstructor$1(yyStart);
    return yyColumn.chunk4.fTypeConstructor;
  }

  /** Actually parse xtc.typical.Type.TypeConstructor. */
  private Result pTypeConstructor$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pKeyword(yyBase);
      if (yyResult.hasValue("of")) {

        yyResult = pAliasedType(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("'of' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeConstructor", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.FieldType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFieldType(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fFieldType) 
      yyColumn.chunk4.fFieldType = pFieldType$1(yyStart);
    return yyColumn.chunk4.fFieldType;
  }

  /** Actually parse xtc.typical.Type.FieldType. */
  private Result pFieldType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pAliasedType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("FieldType", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Type.PolyTypeConstructor.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPolyTypeConstructor(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fPolyTypeConstructor) 
      yyColumn.chunk4.fPolyTypeConstructor = pPolyTypeConstructor$1(yyStart);
    return yyColumn.chunk4.fPolyTypeConstructor;
  }

  /** Actually parse xtc.typical.Type.PolyTypeConstructor. */
  private Result pPolyTypeConstructor$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("`")) {

      yyResult = pUpperIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("of")) {

          yyResult = pLowerIdentifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("PolyTypeConstructor", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'of' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("poly type constructor expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Decimal>.

    yyResult = pDecimalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.FloatingLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatingDecimal>.

    yyResult = pDecimalFloatingLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.DecimalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = difference(yyStart, yyRepetition1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.DecimalFloatingLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalFloatingLiteral(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyC = character(yyRepetition1);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyOption1  = yyRepetition1;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("decimal floating literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExponent) 
      yyColumn.chunk5.fExponent = pExponent$1(yyStart);
    return yyColumn.chunk5.fExponent;
  }

  /** Actually parse xtc.typical.Constant.Exponent. */
  private Result pExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = pExponent$$Plus1(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.Exponent$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent$$Plus1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExponent$$Plus1) 
      yyColumn.chunk5.fExponent$$Plus1 = pExponent$$Plus1$1(yyStart);
    return yyColumn.chunk5.fExponent$$Plus1;
  }

  /** Actually parse xtc.typical.Typical.Exponent$$Plus1. */
  private Result pExponent$$Plus1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = pExponent$$Plus1(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StringLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '\\':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Constant.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("true")) {
      final String v$g$1 = "true";

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("BooleanLiteral", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("false")) {
      final String v$g$2 = "false";

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("BooleanLiteral", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("boolean literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.LowerIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLowerIdentifier(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fLowerIdentifier) 
      yyColumn.chunk5.fLowerIdentifier = pLowerIdentifier$1(yyStart);
    return yyColumn.chunk5.fLowerIdentifier;
  }

  /** Actually parse xtc.typical.Identifier.LowerIdentifier. */
  private Result pLowerIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLowerWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! TYPICAL_KEYWORDS.contains(yyValue)) {

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("lower identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.UpperIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUpperIdentifier(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fUpperIdentifier) 
      yyColumn.chunk5.fUpperIdentifier = pUpperIdentifier$1(yyStart);
    return yyColumn.chunk5.fUpperIdentifier;
  }

  /** Actually parse xtc.typical.Identifier.UpperIdentifier. */
  private Result pUpperIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pUpperWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! TYPICAL_KEYWORDS.contains(yyValue)) {

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("upper identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIdentifier) 
      yyColumn.chunk5.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk5.fIdentifier;
  }

  /** Actually parse xtc.typical.Identifier.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! TYPICAL_KEYWORDS.contains(yyValue)) {

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.LowerWord.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLowerWord(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if (('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("lower word expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.UpperWord.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUpperWord(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("upper word expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fWord) 
      yyColumn.chunk5.fWord = pWord$1(yyStart);
    return yyColumn.chunk5.fWord;
  }

  /** Actually parse xtc.typical.Identifier.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWord$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = difference(yyStart, yyResult.index);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("word expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.typical.Typical.Word$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord$$Star1(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fWord$$Star1) 
      yyColumn.chunk5.fWord$$Star1 = pWord$$Star1$1(yyStart);
    return yyColumn.chunk5.fWord$$Star1;
  }

  /** Actually parse xtc.typical.Typical.Word$$Star1. */
  private Result pWord$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('0' <= yyC) && (yyC <= '9')) ||
          (('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyResult = pWord$$Star1(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = null;

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Identifier.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fKeyword) 
      yyColumn.chunk5.fKeyword = pKeyword$1(yyStart);
    return yyColumn.chunk5.fKeyword;
  }

  /** Actually parse xtc.typical.Identifier.Keyword. */
  private Result pKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (TYPICAL_KEYWORDS.contains(yyValue)) {

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Symbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    TypicalParserColumn yyColumn = (TypicalParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fSymbol) 
      yyColumn.chunk5.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk5.fSymbol;
  }

  /** Actually parse xtc.typical.Symbol.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Symbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('.' == yyC) {

                    yyValue = "<=.";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "<=";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '.':
              {
                yyValue = "<.";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('.' == yyC) {

                    yyValue = ">=.";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = ">=";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '.':
              {
                yyValue = ">.";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('&' == yyC) {

              yyValue = "&&";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('|' == yyC) {

              yyValue = "||";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "=";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyValue = "/.";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "/";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyValue = "%.";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "%";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyValue = "*.";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '.':
              {
                yyValue = "-.";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '>':
              {
                yyValue = "->";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyValue = "+.";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ':':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if (':' == yyC) {

              yyValue = "::";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = ":";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '^':
        {
          yyValue = "^";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '@':
        {
          yyValue = "@";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\'':
        {
          yyValue = "\'";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '`':
        {
          yyValue = "`";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Spacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '(':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('*' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '*':
                      {
                        yyPredMatched = false;

                        yyC = character(yyIndex);
                        if (')' == yyC) {

                          yyPredMatched = true;
                        }

                        if (! yyPredMatched) {

                          yyRepetition2 = yyIndex;
                          continue;
                        } else {
                          yyError = yyError.select("spacing expected", yyStart);
                        }
                      }
                      break;

                    default:
                      {
                        yyRepetition2 = yyIndex;
                        continue;
                      }
                    }
                  }
                  break;
                }

                yyBase = yyRepetition2;
                yyC    = character(yyBase);
                if ('*' == yyC) {
                  yyIndex = yyRepetition2 + 1;

                  yyC = character(yyIndex);
                  if (')' == yyC) {
                    yyIndex = yyIndex + 1;

                    yyRepetition1 = yyIndex;
                    continue;
                  } else {
                    yyError = yyError.select("'*)' expected", yyBase);
                  }
                } else {
                  yyError = yyError.select("'*)' expected", yyBase);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.typical.Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(TYPICAL_KEYWORDS, new String[]
    {"and", "any", "assert", "require", "attribute",
      "bool", "bottom", "else", "error", "equality",
      "float", "float32", "float64", "as", "if", "in",
      "int", "guard", "mlvalue", "match", "namespace",
      "of",
      "scope", "string",
      "symbol", "mltype",
      "warning", "when", "with" ,"reduce", "then",
      "to", "true", "false", "sig", "modify",
      "module", "_", "predicate", "instantiate",
      "import", "eqattribute", "function", "fun", "let",
      "at", "begin", "end", "default", "Node"}
    );
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
